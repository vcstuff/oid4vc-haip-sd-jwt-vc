{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-05-25T00:24:16.537705+00:00",
  "repo": "vcstuff/high-assurance-profile",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pending-close",
      "description": "",
      "color": "860DE9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJcWsFs5lUzvJ",
      "title": "Keys for DPoP should be attested to be highly secure",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/1",
      "state": "OPEN",
      "author": "awoie",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Let's make sure that keys we use for DPoP can be directly attested by the key attestation to be protected by the secure key store of the device (e.g. Secure Element, Secure Enclave etc.).",
      "createdAt": "2023-05-08T10:04:47Z",
      "updatedAt": "2023-05-16T09:55:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "let's also make sure it is optimization and not a requirement in client attestation draft.",
          "createdAt": "2023-05-13T15:34:42Z",
          "updatedAt": "2023-05-13T15:34:42Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "Would that be a DPoP extension?",
          "createdAt": "2023-05-16T09:55:48Z",
          "updatedAt": "2023-05-16T09:55:48Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOJcWsFs5l1z0B",
      "title": "A term alternative to \"verifiable credentials\"..?",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/2",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "need a term that can be used to refer to both verifiable credentials and mdocs, that is not \"Verifiable Credentials\"\r\nsome suggestions: \r\n- digital credentials\r\n- Electronic attestations of attributes\r\n- verifiable attestations",
      "createdAt": "2023-05-13T13:31:06Z",
      "updatedAt": "2023-05-16T09:54:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "\"Electronic attestations of attributes\" sounds good. However in the eIDAS context is one category of credentials whereas the other one is called \"Person Identification Data\" - so EAA would not be perceived as term for all kinds of credentials.\r\n\"verifiable attestations\" to me sounds very much like EAA.\r\n\r\nI think \"digital credentials\" is the best option.   \r\n\r\nPS: you know we will need to change the name of our spec family again once we pick a new term  ;-). I'm fine with that, just stating the obvious. ",
          "createdAt": "2023-05-16T09:54:36Z",
          "updatedAt": "2023-05-16T09:54:36Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOJcWsFs5l1z4o",
      "title": "[ed] URLs to the audience organizations",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/3",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "URLs to \"eIDAS 2.0, California Department of Motor Vehicles, Open Wallet Foundation (OWF), IDunion, GAIN\"",
      "createdAt": "2023-05-13T13:32:14Z",
      "updatedAt": "2023-05-24T22:33:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOJcWsFs5l10xy",
      "title": "Align and expand Scenarios/Business Requirements section ",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/4",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-13T13:42:24Z",
      "updatedAt": "2023-05-17T15:12:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "one from @awoie \r\n```\r\n- customer applies for VC, in-person  (pre-authz) or remote (authz code)\r\n- wallet requests access_token/credential\r\n- downstream process kicks off and decision needs to be made by some special officer and cannot be automated based on prior decisions/authorizations\r\n- wallet has to wait until decision was made\r\n- special officer makes decision\r\n- wallet requests token/credential again and token/credential endpoint can answer with final response.\r\n```",
          "createdAt": "2023-05-15T21:57:30Z",
          "updatedAt": "2023-05-15T21:57:30Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also from @awoie \r\n\r\n> Would it make sense to specifically describe the following scenarios:\r\n> - high-security in-person provisioning with/without human in the loop in downstream processes\r\n> - high-security remote provisioning with/without human in the loop in downstream processes\r\n> - high-security online presentment, same device, cross-device (if we have a good solution for that).\r\n> \r\n> Would it make sense to suggest assurance levels according to eIDAS/NIST?",
          "createdAt": "2023-05-17T15:12:25Z",
          "updatedAt": "2023-05-17T15:12:25Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOJcWsFs5l15aj",
      "title": "Note on JSON serialization and JAdES",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/5",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-13T14:38:43Z",
      "updatedAt": "2023-05-13T14:38:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOJcWsFs5l17Ho",
      "title": "issuer identifier - always HTTPS URL..?",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/6",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Which HTTPS URL does the issuer use when x.509 is used? SAN? if we mandate issuer to do both x.509 and SAN, does that mean issuers must make sure /JWT-issuer is hosted under SAN? Isn\u2019t that pretty limiting? (I am not necessarily opposed to \u201ciss is always a URL, just trying to understand the implications)",
      "createdAt": "2023-05-13T14:53:32Z",
      "updatedAt": "2023-05-24T23:16:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "According to the feedback we got so far on the concept, I think SNA is the way to go. \r\n\r\nI see value in the proposal @tplooker made to always use the same kind of `iss` value. It is especially beneficial if the credential has both the x.509 cert chain and support for web based key resolution, since the verifier can choose what data to use for validation. \r\n\r\nIf the credential only has x.509, it doesn't matter in the end what identifier we use as long as the leaf cert binds that identifier to the public key of the issuer. So using the HTTPS URL doesn't hurt at least and might be inline with the way domain validated certs (and cWACs? @paulbastian) work. \r\n\r\nEven HTTPS URL with paths should work. I checked https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.6 and did not find an indication that this would not be possible. I mention it because as far as I remember someone stated that a SNA would only contain a URL with FQN but no path. \r\n\r\n> Isn\u2019t that pretty limiting?\r\n\r\nIn my opinion, the issuer can freely choose the URL so it should not become a limitation. However, I also think we need implementors' feedback. ",
          "createdAt": "2023-05-16T09:49:48Z",
          "updatedAt": "2023-05-24T22:36:48Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "NONE",
          "body": "I agree using iss field for x509 as well. It has the advantage of having a common identifier for both mechanisms. EV and QWAC work the same way",
          "createdAt": "2023-05-16T10:40:51Z",
          "updatedAt": "2023-05-16T10:40:51Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "If the goal of the x5c is the key attestation, this works fine.\r\n\r\nIf instead policies and additional information like metadata are required, x5c simply doesn't work unless it would be \"inflated\" with custom elements for carrying metadata and policies and grants. That from what can be said about x509, inflating it so much would be like making an 80-year-old man do bodybuilding!\r\n\r\nI suggest the inclusion of OIDC Federation Trust chain in this profile, that's both web attested key and chain of verifiable statements issued by more than a single party.\r\n\r\nthe key question is: what defines the level high? key attestations (as oidc core did for years) or a high level would bring also grants/policies, metadata and all the interop schema as high verifiable and assured?\r\n\r\nSince every issued VC or any kind of attestation should not be repudiable in the future, that's something pertaining the assurance level I think",
          "createdAt": "2023-05-20T20:29:33Z",
          "updatedAt": "2023-05-21T21:49:57Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "@peppelinux This issue is about the question what the identifier of an issuer is in a VC. Since we are leaning towards using a HTTPS URL, that would work for federation, too. ",
          "createdAt": "2023-05-22T07:38:01Z",
          "updatedAt": "2023-05-22T07:38:01Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I agreed, since federation only uses HTTPs but from Draft 29 there's the trust_chain JWS header claim that allows metadata, keys and policies attestation even in offline flows\r\n\r\nan https alone is not attestable in offline flows and x509 doesn't have metadata, policies and trust marks/additional-VCs in it related to the issuer\r\n\r\nfederation trust_chain has",
          "createdAt": "2023-05-22T20:42:19Z",
          "updatedAt": "2023-05-22T20:42:19Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "@peppelinux \r\nI have to admit I don't fully understand your arguments. This issue is about the value of the `iss` value in the credential. A HTTPS URL works fine with OpenID Federation as well, right? So I don't see a problem. ",
          "createdAt": "2023-05-23T07:06:11Z",
          "updatedAt": "2023-05-23T07:06:11Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "yes, I went quite out of the border\r\n\r\nThe question is there any interest to have different kind of issuer identifiers?\r\n\r\nI'm in favor of HTTP URLs, even if there may be some cases where a did resolution methods resolve to HTTPs URL as well, as discussed in the issue below:\r\nhttps://github.com/vcstuff/draft-terbu-sd-jwt-vc/issues/41#issuecomment-1546743042\r\n\r\nAnyway, if there are milestone in this project this question doesn' seem a priority since that this profile can satisfy its scope using HTTPs URL\r\n\r\nso accept my excuse for the noise, it was just for sharing\r\n\r\n",
          "createdAt": "2023-05-23T17:29:21Z",
          "updatedAt": "2023-05-23T17:29:21Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@paulbastian \r\n> EV and QWAC work the same way\r\n\r\nCould you please elaborate a bit? what is EV?",
          "createdAt": "2023-05-24T22:37:22Z",
          "updatedAt": "2023-05-24T22:37:22Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think what I would like to see is a clear validation logic, something like:\r\n- when only x509 is used (kid JOSE header is not present), iss is a SAN. when verifying, must be an absolute match btw the value in iss and x509 leaf cert.\r\n- when only web PKI based approach is used (x5c JOSE header is not present), iss is a URL where the key is hosted, it can include path and subdomain.\r\n- when both x509 and web PKI based are used (both x5c and kid header is present), iss is a URL where the key is hosted, can include path and subdomain. Verifier must strip down path and subdomain and use only the domain when comparing with the SAN in x509 cert.\r\n\r\nnot sure it is clean to use header parameters as a switch, but that's how the verifier will determine which mechanism is used, right?\r\n\r\ndon't know if it is a limitation, but essentially, Web PKI based approach must host the keys at the domain that is also in the x509 cert.",
          "createdAt": "2023-05-24T23:16:37Z",
          "updatedAt": "2023-05-24T23:16:37Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJcWsFs5l1_ZB",
      "title": "issuer key resolution requirements for each entity:",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/7",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "there are currently two options for issuer key resolution: web PKI based one and X.509 based one. current text states, \"iissuer supports one of the options, wallet and verifier support both\", but @tlodderstedt is right that this will make the life of verifiers (and wallets) really hard. \r\nprobably need to discuss what it means for the issuer to support both x.509 and web pki based...",
      "createdAt": "2023-05-13T15:18:02Z",
      "updatedAt": "2023-05-22T20:32:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "since the revocation for x509 should be always attested with web retrieval mechanisms, and that x509 works for key attestation only and needs to be extended with custom attributes to satisfy the requirements for policies and metadata/capabilities retrieval\r\n\r\nI'm in favour of using federation trust_chain as the best way to go to satisfy all the requirements for a high assurance profile that attests also grants and capabilities and not just the identity of an entity\r\n\r\nthen the question would be, where are the requirements?\r\nIt is still a work in progress but in a way or another it is becoming part of our shared knowledge:\r\n\r\nhttps://docs.google.com/document/d/1Dk_8UmytCI4VhCx5VMnXmEzdXRvgJozGeq1GNHZOQik/edit#heading=h.jb7a7nddoxft",
          "createdAt": "2023-05-22T20:32:01Z",
          "updatedAt": "2023-05-22T20:32:01Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJcWsFs5l2Ajy",
      "title": "client_id_scheme and client_assertion_type",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/8",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "need to discuss the relationship between `client_id_scheme` and `client_assertion_type`. \r\n- one way to think is: client_assertion_type acts as client_id_scheme so no need for a client_id_scheme\r\n- another is: client_id_scheme is about how to process client_id and how to obtain client metadata, while client_assertion_type is which client authentication type to use, so they cannot be the same.\r\n\r\nmaybe the question is, when client_assertion_type is wallet attestation, do we expect client metadata to be obtained from wallet attestation or can there be other options?",
      "createdAt": "2023-05-13T15:31:23Z",
      "updatedAt": "2023-05-16T09:35:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "In my opinion, `client_id_scheme` and `client_assertion_type` serve the same purpose. \r\n\r\n> maybe the question is, when client_assertion_type is wallet attestation, do we expect client metadata to be obtained from wallet attestation or can there be other options?\r\n\r\nWhat client metadata do you mean? redirect URI, crypto algorithms? I would expect them to be communicated using the standard mechanisms, either oob or using a suitable parameter (just saw `client_metadata` is not in the VCI spec yet). ",
          "createdAt": "2023-05-16T09:35:46Z",
          "updatedAt": "2023-05-16T09:35:46Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJcWsFs5l2Am6",
      "title": "define \"ephemeral credential\" as a term..?",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/9",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "from @peppelinux",
      "createdAt": "2023-05-13T15:31:58Z",
      "updatedAt": "2023-05-20T23:26:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i personally don't think it is necessary..",
          "createdAt": "2023-05-13T15:32:10Z",
          "updatedAt": "2023-05-13T15:32:10Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "The meaning of ephemeral is given by the value its owner give to it, and then how she uses the credential\r\n\r\nat the same time using this term \"ephemeral\" we assume that the credential is a one-time-credential, while another case is vc used for specific audiences and requested/issued/obtained just for that, since it will be used more than a single time (audience constrained)\r\n\r\nbut at the same time, these are not properties of the credential itself, but the usage/scope given to these by its owner\r\n\r\ninteresting anyway :-)\r\n\r\n",
          "createdAt": "2023-05-20T23:25:48Z",
          "updatedAt": "2023-05-20T23:26:17Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJcWsFs5l2CwV",
      "title": "`client_id` value of the wallet during issuance",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/10",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "The text current wallet attestation draft says:\r\n> The JWT MUST contain a \"sub\" (subject) claim with a value corresponding to the \"client_id\" of the OAuth client.\r\n\r\nthe thing is.. when there has been no pre-existing relationship between the issuer and the wallet, which `client_id` value does the wallet uses..?",
      "createdAt": "2023-05-13T15:55:49Z",
      "updatedAt": "2023-05-23T17:33:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "discussed with @tlodderstedt. `sub` is a self-attested value from the wallet front end to the wallet backend. the issuer does not really need to understand `sub`, more imp for audit trails and user consent. ",
          "createdAt": "2023-05-13T16:41:15Z",
          "updatedAt": "2023-05-13T16:41:15Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "@paulbastian what do you do in your current implementation?",
          "createdAt": "2023-05-16T09:17:25Z",
          "updatedAt": "2023-05-16T09:17:25Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I suggest the jwk thumbprint value for the sub value (and consequently for the client_id in the issuance flow)\r\n\r\nthe sub will be always derived from the cnf.jwk, producing a privacy-preserving value since it would be like a kid\r\n\r\nthis proposal assumes that the wallet instance could only be tracked with its public key, considering that it should have/use more than a single key, the risk is mitigated",
          "createdAt": "2023-05-22T20:26:56Z",
          "updatedAt": "2023-05-22T20:26:56Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "The `sub` could just be set to a fix value per wallet provider (most likely sub==iss). This is sufficient for authorization and auditing and it is privacy preserving since the wallet instances cannot be identified. ",
          "createdAt": "2023-05-23T07:14:33Z",
          "updatedAt": "2023-05-23T07:14:57Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I'm not in favour of sub == iss since Wallet Provider and Wallet Instance are different subjects\r\n\r\nthe Wallet Provider (iss) issues the Wallet Instance Attestation to a Wallet Instance (sub), so these are definitively different\r\n\r\nif we admit that the only way to identify/trace a wallet instance is exploiting the public key (used in Holder binding) ad that the Wallet Instance should have more than a key and obtain fresh documents with a different key, we may assume that the subject identifier if the key, that's not unique, and that from this it could be derived the sub value",
          "createdAt": "2023-05-23T17:33:02Z",
          "updatedAt": "2023-05-23T17:33:02Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJcWsFs5l2GA9",
      "title": "value of `client_id_scheme`...",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/11",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The value of the `client_id_scheme` parameter MUST be `wallet_attestation`.",
      "createdAt": "2023-05-13T16:42:02Z",
      "updatedAt": "2023-05-16T09:30:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "Where would we use this client id scheme?",
          "createdAt": "2023-05-14T07:54:59Z",
          "updatedAt": "2023-05-16T09:30:36Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOJcWsFs5l2G0q",
      "title": "relationship between `sub` and pop key in wallet attestation",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/12",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@peppelinux: a client_id or a sub value for this use case can be derived with a simple thumbprint value of the cnf.jwk, just to bind the identity of the wallet instance to one of its public key\r\n\r\nI would suggest to leave this choice whether to bind sub and pop key to the wallet frontend",
      "createdAt": "2023-05-13T16:54:14Z",
      "updatedAt": "2023-05-23T17:36:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "this issue is related to the doubts on removing client_id from the token endpoint (issuance phase)\r\n\r\nI'm in favor to keep client_id since there's a legacy schema for the token endpoint that we are technically able to respect, so I'd not break an existing token endpoint, keeping the client_id as it is using a resonable strategy to create it for the wallet instance without breaking privacy (multiple client_id each one derived from a public key of the wallet instance)",
          "createdAt": "2023-05-22T20:22:19Z",
          "updatedAt": "2023-05-22T20:22:19Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "I don't see a reason for having a relationship between sub and the pop key. I think the sub could just be set to the wallet provider name/ id. ",
          "createdAt": "2023-05-23T07:16:49Z",
          "updatedAt": "2023-05-23T07:16:49Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Is this thread also relate to the one below?\r\nhttps://github.com/vcstuff/high-assurance-profile/issues/10#issuecomment-1559871971",
          "createdAt": "2023-05-23T17:36:07Z",
          "updatedAt": "2023-05-23T17:36:07Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJcWsFs5l9KTr",
      "title": "[placeholder] add trust mechanism in the future versions ",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/13",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "currently out of scope, but agreement to add before final",
      "createdAt": "2023-05-15T17:41:50Z",
      "updatedAt": "2023-05-22T07:45:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "I think the profile with key resolution and identifier authentication adds a lot in terms of interoperability. On the other hand, there are so many different technical means to manage trust, we will have a hard time to pin down THE one or two to endorse by the profile. I don't think we should delay publication due to this topic. ",
          "createdAt": "2023-05-16T09:29:48Z",
          "updatedAt": "2023-05-16T09:29:48Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "My only concern is that also this time new specifications are born that do not address the crucial issue of trust, in a paradigm where the citizen is at the center and consequently alone, considering that there's an important demand of the trust model, at a design level, and consequentially the demand the technical and implementation profiles for certifying trust.\r\n\r\nConsidering that profiles for attesting trust exist, it would be really important to at least reference them in this new spec (and answer simple questions, like the ones here: [draft-looker-oauth-attested-key-based-client- authentication](https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/issues/3#issuecomment-1555952616)) by giving some non normative example about how to deal with these, in this new specs.\r\n\r\nin addition to the concern, I want to remove the fear that not wanting/being able to deal with the issue of trust, consequently it will not be dealt with at all, leaving a huge design hole that would allow anyone to do it \"in their own way\" and with clear security risks.",
          "createdAt": "2023-05-20T20:18:12Z",
          "updatedAt": "2023-05-20T20:19:00Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "One step after the other. Our first concern is to provide interoperability across implementations of OID4VC with SD-JWT on a global basis. And as always, interoperability means to reduce optionality. On the other hand, less optionality also reduces the number of potential implementations, since not all requirements can be covered. So we need to make sure we provide interop while having an broad enough scope for adoption. So we are not only looking for eIDAS ARF, we are also, for example, looking for small business intending to get something out onto the streets this year. In their deployments, trust might be as simple as the wallets and verifiers having a list of issuers (as a list of URLs). eIDAS ARF will certainly use other mechanisms, other deployments around the globe will perhaps use other mechanisms, too. It's their responsibility, to add their mechanism to our (global) interop profile. Modularity is the key here. \r\nFor eIDAS ARF, I assume the ARF/rule books will add whatever is necessary. Perhaps ETSi will do that on the ling run.  ",
          "createdAt": "2023-05-22T07:45:26Z",
          "updatedAt": "2023-05-22T07:45:26Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOJcWsFs5l9LIs",
      "title": "Value of a custom URL scheme",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/14",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "current value is `haip` standing for \"high assurance interop profile\".\r\n\r\nif you come up with a better one, I will buy you a drink",
      "createdAt": "2023-05-15T17:44:43Z",
      "updatedAt": "2023-05-20T20:23:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "semantically, the question is <<High assurance interop profile, of what?>>\r\n\r\nthe schema should have at least a subject\r\n\r\nvc-hap://?\r\n\r\nbut, anyway, if there's an high level, where are the middle and the low?\r\nHigh is high in comparison to something that is less high :-)\r\n\r\naccording to what already made with ACR Values, we should define three levels and then say, this is \"high\" ",
          "createdAt": "2023-05-20T20:23:45Z",
          "updatedAt": "2023-05-20T20:23:45Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJcWsFs5l-o5x",
      "title": "communicating extra wallet capabilities when obtaining the request object ",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/15",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "verifier sends a request_uri, when wallet hits that request_uri, it can communicate information such as version control. maybe using the headers. not urgent",
      "createdAt": "2023-05-15T22:11:01Z",
      "updatedAt": "2023-05-22T11:39:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "wallet capabilities should be attested in the wallet instance attestation\r\nwallet should submit its wallet instance attestation to the request_uri URL using the HTTP POST method",
          "createdAt": "2023-05-20T23:39:17Z",
          "updatedAt": "2023-05-20T23:39:17Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "I guess this issue is about the verifier to wallet communication (presentation), specifically the callback from the wallet to the verifier at the request_uri. MSFT currently passes additional information in HTTP request headers to allow the verifier to produce a request object tailored for the capabilities of the wallet. We are considering to add this to the spec. \r\nI don't see why there is any attestation required.  ",
          "createdAt": "2023-05-22T07:30:20Z",
          "updatedAt": "2023-05-22T07:30:20Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "The Wallet Solution has many capabilities, these are attested by Wallet Provider to the Wallet Instance with the Wallet Instance Attestation, this latter should contain the policy and the interop metadata attesting the wallet instance capabilities and should be presented by Wallet Instance to prove its capabilities\r\n\r\nthis is the picture I have in mind",
          "createdAt": "2023-05-22T11:39:53Z",
          "updatedAt": "2023-05-22T11:39:53Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOJcWsFs5l-5KS",
      "title": "using a VC for Verifier Attestation",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/16",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "the core idea is: \"Verifier obtains a VC from a trusted third party, a VC includes a key material of a Verifier, authorization request is signed using that key\". need to define a schema for that VC.",
      "createdAt": "2023-05-15T23:33:45Z",
      "updatedAt": "2023-05-20T23:30:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is what I have now: \"When the Client Identifier Scheme is `verifier_attestation`, the Client Identifier MUST equal `sub` claim value in the Verifier attestation JWT. The request MUST be signed with the private key corresponding to the public key in the `cnf` claim in the Verifier attestation JWT. The Verifier attestation VC MUST be added to a newly defined `verifier_attestation` JOSE Header of a request object. The Wallet MUST validate the signature on the Verifier attestation JWT by a trusted third party. Verifier metadata MUST be obtained from the Verifier attestation JWT.\"",
          "createdAt": "2023-05-16T03:05:58Z",
          "updatedAt": "2023-05-16T03:05:58Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "Just check back with ppl from ETSi. They are in favor of (in addition to x.509 for qWACs and qSeals) having a VC-based mechanism for Verifier authentication.  ",
          "createdAt": "2023-05-16T15:27:05Z",
          "updatedAt": "2023-05-16T15:27:05Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "we are not forced in using verifier_attestation JOSE claim, since we may use a trust_chain jose claim\r\n\r\nthe attestation is flat, while the trust chain attests all the trust relationships between the parties that attests the accreditation status of an entity, without a central registry",
          "createdAt": "2023-05-20T23:30:52Z",
          "updatedAt": "2023-05-20T23:30:52Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJcWsFs5mFYZA",
      "title": "add back client_metadata?",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/17",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I left it out in the first pass.\r\nany protocol-related parameter that can be passed in the client_metadata like `subject_syntax_types_supported` is hard-coded in the profile. \r\nif there is a need to verifier related metadata like `logo_url`, `client_name`, etc. we should add it back",
      "createdAt": "2023-05-16T20:20:35Z",
      "updatedAt": "2023-05-22T20:15:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "federation trust_chain bring the verifier metadata in the trust attestation, and the federation_entity metadata defines a standard scheme for every kind of participant, this is here\r\n\r\nhttps://openid.net/specs/openid-connect-federation-1_0.html#section-4.7",
          "createdAt": "2023-05-22T20:15:39Z",
          "updatedAt": "2023-05-22T20:15:39Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOJcWsFs5mFZaL",
      "title": "attestation of the key signing SIOP ID Token",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/18",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "do we assume that the key used for the signature of the SIOPv2 id token must be attestable with a wallet instance attestation? from @peppelinux",
      "createdAt": "2023-05-16T20:24:05Z",
      "updatedAt": "2023-05-23T17:38:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "I don't think so. it's the wallet (provider) that is being attested, not the key. Like for the issuance of credentials, where the wallet is attested and not the key the credential is bound to.",
          "createdAt": "2023-05-16T20:27:44Z",
          "updatedAt": "2023-05-16T20:27:44Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "My bad since I didn't understand.\r\n\r\nI assume that the SIOP, then the material issuer of the id token, is the Wallet Instance and not the Wallet Provider.\r\nI assume that a SIOP may issue an id token including the wallet instance attestation containing the public key used to verify the signature of the id token, since the wallet instance attestation has the holder binding\r\n\r\nthe verifier given the id token and the wallet instance attestation, is able to trust that the wallet is secure and compliat to eidas, considering that the Wallet Instance Attestation SHOULD contain the trust chain (or x5c...) to give the proof that the Wallet Provider, that's its issuer, is reliable and attestable as trustworthy ",
          "createdAt": "2023-05-20T20:36:26Z",
          "updatedAt": "2023-05-20T20:36:26Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "> I assume that a SIOP may issue an id token including the wallet instance attestation containing the public key used to verify the signature of the id token, since the wallet instance attestation has the holder binding\r\n\r\nI don't understand the meaning of \"since the wallet instance attestation has the holder binding\". \r\n\r\nOur concept for attestation is pretty simple. If the verifier wants an attestation of the wallet (along with the SIOP response), it requests a wallet attestation VC in the same transaction. So technical speaking, the verifier sends a combined SIOP + OID4VP request. The wallet attestation VC is the kind of VC used to authenticate towards issuers during credential issuance.  ",
          "createdAt": "2023-05-22T07:36:29Z",
          "updatedAt": "2023-05-22T07:36:29Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "> I don't understand the meaning of \"since the wallet instance attestation has the holder binding\".\r\n\r\n`cnf` claim in the payload of the Wallet Instance Attestation binds the holder public key in the JWS\r\n\r\n> it requests a wallet attestation VC in the same transaction.\r\n\r\nNot sure since the pseudonym should be also presented in offline flows. The Wallet Instance Attestation should expire and at the same time be usable in a configured time window\r\n\r\nif the wallet instance should have to ask a wallet instance attestation for every id token it issues the offline flows would not possible with pseudonymization\r\n\r\nI agree with your solution and at the same time I find the limits above, so I'd go for a wallet instance attestation usable in offline flows for pseudonymizations",
          "createdAt": "2023-05-22T20:13:50Z",
          "updatedAt": "2023-05-22T20:13:50Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "> cnf claim in the payload of the Wallet Instance Attestation binds the holder public key in the JWS\r\n\r\nThat seems to me a pretty constrained concept. What is the reason for this tight coupling?\r\n\r\nre offline: wallet attestations can be pre-fetched (batch issuance) and used in offline scenarios, too. ",
          "createdAt": "2023-05-23T07:23:44Z",
          "updatedAt": "2023-05-23T07:23:44Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "how to establish that the wallet instance that has issued that id token is the same that own that wallet instance attestation, since this latter is the sole proof that the wallet instance is reliable?",
          "createdAt": "2023-05-23T17:38:11Z",
          "updatedAt": "2023-05-23T17:38:11Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOJcWsFs5mFlpb",
      "title": "How to constrain PE",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/19",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "how to constraint `fields`: \r\n- path (can the JSONPath be constrained?)\r\n- filter (this is a JSON Schema! Must be constrained!)\r\n",
      "createdAt": "2023-05-16T21:04:09Z",
      "updatedAt": "2023-05-16T21:04:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOJcWsFs5mFp_J",
      "title": "requesting presentation of 1 out of n credentials",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/27",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "One way is to use \"submission_requirements\". Another, arguably easier, way is to just state that whatever is requested, the wallet will always respond with a single credential, so no need the submission_requirement at all.",
      "createdAt": "2023-05-16T21:26:34Z",
      "updatedAt": "2023-05-18T14:52:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "NONE",
          "body": "I have come to the conclusion that we should support multiple credentials in a response (for now at least). There are examples being discussed in the LSPs (PID + mDL) and the plugfest 3 (badge + work permit) with multiple credentials. I'm not sure the technical implementation in the end will require to return the credentials in the same response. However, we should at least allow for now and revisit later. ",
          "createdAt": "2023-05-18T14:52:58Z",
          "updatedAt": "2023-05-18T14:52:58Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOJcWsFs5mFqwt",
      "title": "\u201cVerifiable Credentials\u201d or \u201cDigital Credentials\u201d..?",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/28",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Can we please rename \u201cVerifiable Credentials\u201d to \u201cDigital Credentials\u201d? that\u2019s the term already used in other OIDF whitepapers. to OID4DCI and OID4DCP and OID4DC",
      "createdAt": "2023-05-16T21:29:13Z",
      "updatedAt": "2023-05-16T21:29:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOJcWsFs5mK4ks",
      "title": "make iat in SD-JWT selectively disclosable during presentation",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/29",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "from @peppelinux\r\n> well, the \"human behaviour\" may create the practice to get you to update the PID on your birthday, producing a certain information leakage in the meaning of iat. I propose that iat should be in MAY and that there is no problem with making it opaque and SD",
      "createdAt": "2023-05-17T15:11:17Z",
      "updatedAt": "2023-05-17T15:11:17Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOJcWsFs5mRDYS",
      "title": "Requesting credentials with scope only",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/30",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> scope parameter MUST be communicated from the Issuer to the Wallet either in the Credential Offer, or Credential Issuer metadata.\r\n\r\nWe need to define the respective issuer metadata.",
      "createdAt": "2023-05-18T14:31:21Z",
      "updatedAt": "2023-05-22T20:07:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "using OIDC Federation trust_chain JWS header, the metadata of the issuer is derived from the trust chain\r\nand cannot be repudiated by the issuer, even if its keys will change in the future\r\n\r\noidc dynamic client registration has defined the metadata parameter \"scopes\", is there the possibility to use the same also in the credential issuer metadata?",
          "createdAt": "2023-05-21T00:00:28Z",
          "updatedAt": "2023-05-22T20:07:51Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJcWsFs5mRQUg",
      "title": "JSON Serialization mandatory?",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/31",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm not sure whether the profile should make the JSON Serialization mandatory. Are there libraries avalaible? Are there enough use cases justifying it? So far, I see JAdES as a technical mechanisms for long term validation only. But long term validation is a pretty advanced topic and might only be needed for some credentials. ",
      "createdAt": "2023-05-18T15:04:55Z",
      "updatedAt": "2023-05-18T15:04:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 32,
      "id": "I_kwDOJcWsFs5ma4E_",
      "title": "Key attestation methods",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/32",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I read here\r\n\r\nhttps://github.com/vcstuff/high-assurance-profile/blob/main/draft-high-assurance-profile-oid4vc-sd-jwt-vc.md#issuer-identification-and-key-resolution-to-validate-an-issued-credential-issuer-key-resolution\r\n\r\nthat only x509 and .well-known/jwt-issuer MUST be supported\r\n\r\nAt the same time I have the \"perception\" that Federation has a higher level for the attestation of requirements and keys, since it brings metadata, policy and custom attestations (trust marks), and that todate we don't have clear requirements to compare x509 or .well-known/jwt-issuer more or less high.\r\n\r\nSince this new specification is dedicated to the High profile, I think it is appropriate to do a PR to obtain the JWS `trust_chain` header parameter within this new profile",
      "createdAt": "2023-05-20T23:50:03Z",
      "updatedAt": "2023-05-20T23:50:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDOJcWsFs5mqfC4",
      "title": "Move Credential Refresh to Implementation Consideration",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/34",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, the profile requires the implementation of Refresh Tokens for Credential refresh. This is especially needed for refresh of short living credentials and for gathering fresh copies of RP-specific/ephemeral credential. \r\n\r\nThose might be edge cases, so I suggest to replace the hard requirement by an implementation consideration how to solve those scenarios. This will make the implementation of the profile easier.  ",
      "createdAt": "2023-05-23T16:20:53Z",
      "updatedAt": "2023-05-23T16:20:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOJcWsFs5mqfus",
      "title": "Issuer URL and x.509 certs",
      "url": "https://github.com/vcstuff/high-assurance-profile/issues/35",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Use of DNSname SAN in credentials with x5c and web based lookup forces hosting of the jwt-issuer metadata at the top of the FQDN. Can we relax the requirement and allow for issuer URLs with path components?",
      "createdAt": "2023-05-23T16:22:19Z",
      "updatedAt": "2023-05-24T23:17:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "copying comment form Issuer #6.\r\n\r\n---\r\nI think what I would like to see is a clear validation logic, something like:\r\n- when only x509 is used (kid JOSE header is not present), iss is a SAN. when verifying, must be an absolute match btw the value in iss and x509 leaf cert.\r\n- when only web PKI based approach is used (x5c JOSE header is not present), iss is a URL where the key is hosted, it can include path and subdomain.\r\n- when both x509 and web PKI based are used (both x5c and kid header is present), iss is a URL where the key is hosted, can include path and subdomain. Verifier must strip down path and subdomain and use only the domain when comparing with the SAN in x509 cert.\r\n\r\nnot sure it is clean to use header parameters as a switch, but that's how the verifier will determine which mechanism is used, right?\r\n\r\ndon't know if it is a limitation, but essentially, Web PKI based approach must host the keys at the domain that is also in the x509 cert.",
          "createdAt": "2023-05-24T23:17:55Z",
          "updatedAt": "2023-05-24T23:17:55Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 33,
      "id": "PR_kwDOJcWsFs5RJ7Me",
      "title": "proposed changes after first review",
      "url": "https://github.com/vcstuff/high-assurance-profile/pull/33",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-23T14:44:18Z",
      "updatedAt": "2023-05-24T22:32:31Z",
      "baseRepository": "vcstuff/high-assurance-profile",
      "baseRefName": "main",
      "baseRefOid": "591a60c45c9a4d2b9323d4d89722be0effb7b88a",
      "headRepository": "vcstuff/high-assurance-profile",
      "headRefName": "tl-review",
      "headRefOid": "582a46356e8563f35cd8fc27f107225718319812",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJcWsFs5V-p4w",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:05:02Z",
          "updatedAt": "2023-05-24T18:05:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nThis document is not a specification, but a profile. It refers to the specifications required for implementations to interoperate among each other and for the optionalities mentioned in the referenced specifications, defines the set of features to be mandatory to implement.\r\n```",
              "createdAt": "2023-05-24T18:05:02Z",
              "updatedAt": "2023-05-24T18:05:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-tv9",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:16:34Z",
          "updatedAt": "2023-05-24T18:16:35Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nThe profile uses OpenID for Verifiable Credential Issuance [@!OIDF.OID4VCI] and OpenID for Verifiable Presentations [@!OIDF.OID4VP] as the base protocols for issuance and presentation of Credentials, respectively. The credential format used in the profile are W3C Verifiable Credentials secured using Selective Disclosure for JWTs (SD-JWT) according to the VC Data Model v2.0 [@VC-DATA], designated as VC-SD-JWTs. Additionally, considerations are given on how deployments can perform a combined issuance of credentials in both VC-SD-JWT and ISO mdoc [@ISO.18013-5] formats.\r\n```",
              "createdAt": "2023-05-24T18:16:34Z",
              "updatedAt": "2023-05-24T18:16:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-v9J",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:22:52Z",
          "updatedAt": "2023-05-24T18:22:52Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "why did you remove `instance`?",
              "createdAt": "2023-05-24T18:22:52Z",
              "updatedAt": "2023-05-24T18:22:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-wxi",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:24:52Z",
          "updatedAt": "2023-05-24T18:24:53Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n* Protocol for User Authentication by the Wallet at a Verifier (SIOP v2)\r\n```",
              "createdAt": "2023-05-24T18:24:52Z",
              "updatedAt": "2023-05-24T18:24:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-xgp",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:26:11Z",
          "updatedAt": "2023-05-24T18:26:11Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nNote: The Authorization Code flow does not require a Credential Offer from the Issuer to the Wallet. However, it is included in the feature set of the Credential Offer because it might be easier to implement with existing libraries and on top of existing implementations than the pre-authorized code Grant Type.\r\n\r\nBoth sending Credential Offer same-device and cross-device is supported.\r\n```",
              "createdAt": "2023-05-24T18:26:11Z",
              "updatedAt": "2023-05-24T18:29:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-yCp",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:27:37Z",
          "updatedAt": "2023-05-24T18:27:37Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n* MUST support sender-constrained Tokens using a mechanism as defined in [@!I-D.ietf-oauth-dpop].\r\n\r\nBoth Wallet initiated and Issuer initiated issuance is supported.\r\n```",
              "createdAt": "2023-05-24T18:27:37Z",
              "updatedAt": "2023-05-24T18:27:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-zQj",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:31:11Z",
          "updatedAt": "2023-05-24T18:31:12Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n   * Refresh tokens MUST be supported for credential refresh.\r\n   * Wallets MUST support deferred authorization by being able to process the Token error response parameters `authorization_pending` and `slow_down`, and the credential offer parameter `interval`.\r\n   * The wallet attestation JWT scheme is defined in (#wallet-attestation-schema).\r\n```",
              "createdAt": "2023-05-24T18:31:12Z",
              "updatedAt": "2023-05-24T18:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-z6_",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:33:03Z",
          "updatedAt": "2023-05-24T18:33:03Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n* The Credential Issuer MUST publish a mapping of every Credential Type it supports to a scope value.\r\n```",
              "createdAt": "2023-05-24T18:33:03Z",
              "updatedAt": "2023-05-24T18:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-0lW",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:34:49Z",
          "updatedAt": "2023-05-24T18:34:50Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n   * `client_id_scheme` value MUST be either `x509_san_dns` or `verifier_attestation`. Wallet MUST support both. Verifier MUST support at least one. (pending OID4VCI PR#485 for x509, need a OID4VCI PR on verifier_attestation)\r\n```",
              "createdAt": "2023-05-24T18:34:50Z",
              "updatedAt": "2023-05-24T18:34:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-0tS",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:35:14Z",
          "updatedAt": "2023-05-24T18:35:14Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "```suggestion\r\n   * As a way to invoke the Wallet, at least a custom URL scheme `haip://` MUST be supported. Implementations MAY support other ways to invoke the wallets as agreed by trust frameworks/ecosystems/jurisdictions, not limited to using other custom URL schemes.\r\n```",
              "createdAt": "2023-05-24T18:35:14Z",
              "updatedAt": "2023-05-24T18:35:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-0xi",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:35:24Z",
          "updatedAt": "2023-05-24T18:35:25Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "```suggestion\r\nAs credential format, VC-SD-JWT as defined in [!I-D.ietf-terbu-sd-jwt-vc] MUST be used.\r\n```",
              "createdAt": "2023-05-24T18:35:25Z",
              "updatedAt": "2023-05-24T18:35:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-8A8",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:56:30Z",
          "updatedAt": "2023-05-24T18:56:31Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "this seems duplicative with line 192. how about the order of 194 -> 192&196 consolidated?",
              "createdAt": "2023-05-24T18:56:30Z",
              "updatedAt": "2023-05-24T18:56:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-8M4",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:57:03Z",
          "updatedAt": "2023-05-24T18:57:03Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "I think this is an important note?",
              "createdAt": "2023-05-24T18:57:03Z",
              "updatedAt": "2023-05-24T18:57:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-8XO",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:57:30Z",
          "updatedAt": "2023-05-24T18:57:30Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "```suggestion\r\nNote: If there is a requirement to provide the Subject\u2019s identifier assigned and maintained by the Issuer, `sub` claim MAY be used. There is no requirement for a binding to exist between `sub` and `cnf` claims. See section X in [!I-D.draft-terbu-sd-jwt-vc] for implementation considerations.\r\n```",
              "createdAt": "2023-05-24T18:57:30Z",
              "updatedAt": "2023-05-24T18:57:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V-8qK",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:58:17Z",
          "updatedAt": "2023-05-24T18:58:18Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "```suggestion\r\nNote: If there is a requirement to communicate information about the verification status and identity assurance data of the claims about the subject, the syntax defined by [@!OIDF.ekyc-ida] SHOULD be used. It is up to each jurisdiction and ecosystem, whether to require it to the implementers of this profile.\r\n```",
              "createdAt": "2023-05-24T18:58:17Z",
              "updatedAt": "2023-05-24T18:58:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V_99u",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T22:29:53Z",
          "updatedAt": "2023-05-24T22:29:53Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "```suggestion\r\nThis profile supports two ways to represent and resolves the key required to validate the issuer signature of a VC-SD-JWT, web PKI-based key resolution and x.509 certificates.\r\n```",
              "createdAt": "2023-05-24T22:29:53Z",
              "updatedAt": "2023-05-24T22:29:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V_-TS",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T22:31:39Z",
          "updatedAt": "2023-05-24T22:31:40Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "I think we can remove this section (lines 215-217) since now HB JWT is defined in SD-JWT spec itself and oliver's draft mandates HB jwt?",
              "createdAt": "2023-05-24T22:31:40Z",
              "updatedAt": "2023-05-24T22:31:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJcWsFs5V_-cO",
          "commit": {
            "abbreviatedOid": "582a463"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "done reviewing. suggested some changes.",
          "createdAt": "2023-05-24T22:32:31Z",
          "updatedAt": "2023-05-24T22:32:31Z",
          "comments": []
        }
      ]
    }
  ]
}